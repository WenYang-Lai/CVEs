From 63dffa25780cbe43e66e04522113266fc448fe06 Mon Sep 17 00:00:00 2001
From: Jann Horn <jannh@google.com>
Date: Fri, 6 May 2016 20:49:59 -0700
Subject: [PATCH] perf: avoid calling access_ok() under KERNEL_DS

Performance events can fire while code is executing under KERNEL_DS.
Using a crafted userland stackframe, this can be used to leak data
from arbitrary kernelspace addresses on arm/arm64.

This fixes the arm/arm64 code and simplifies the dodgy x86 code.

Signed-off-by: Jann Horn <jannh@google.com>
Cc: stable@vger.kernel.org
---
 arch/arm/kernel/perf_callchain.c   |  4 ++++
 arch/arm64/kernel/perf_callchain.c | 11 +++++++++--
 arch/x86/events/core.c             | 10 ++--------
 3 files changed, 15 insertions(+), 10 deletions(-)

diff --git a/arch/arm/kernel/perf_callchain.c b/arch/arm/kernel/perf_callchain.c
index 4e02ae5..58a0a98 100644
--- a/arch/arm/kernel/perf_callchain.c
+++ b/arch/arm/kernel/perf_callchain.c
@@ -36,6 +36,7 @@ user_backtrace(struct frame_tail __user *tail,
 	struct frame_tail buftail;
 	unsigned long err;
 
+	/* safe because perf_callchain_user forces USER_DS */
 	if (!access_ok(VERIFY_READ, tail, sizeof(buftail)))
 		return NULL;
 
@@ -62,6 +63,7 @@ void
 perf_callchain_user(struct perf_callchain_entry *entry, struct pt_regs *regs)
 {
 	struct frame_tail __user *tail;
+	mm_segment_t oldfs = get_fs();
 
 	if (perf_guest_cbs && perf_guest_cbs->is_in_guest()) {
 		/* We don't support guest os callchain now */
@@ -75,9 +77,11 @@ perf_callchain_user(struct perf_callchain_entry *entry, struct pt_regs *regs)
 
 	tail = (struct frame_tail __user *)regs->ARM_fp - 1;
 
+	set_fs(USER_DS);
 	while ((entry->nr < PERF_MAX_STACK_DEPTH) &&
 	       tail && !((unsigned long)tail & 0x3))
 		tail = user_backtrace(tail, entry);
+	set_fs(oldfs);
 }
 
 /*
diff --git a/arch/arm64/kernel/perf_callchain.c b/arch/arm64/kernel/perf_callchain.c
index ff46654..29b33e2 100644
--- a/arch/arm64/kernel/perf_callchain.c
+++ b/arch/arm64/kernel/perf_callchain.c
@@ -36,7 +36,9 @@ user_backtrace(struct frame_tail __user *tail,
 	struct frame_tail buftail;
 	unsigned long err;
 
-	/* Also check accessibility of one struct frame_tail beyond */
+	/* Also check accessibility of one struct frame_tail beyond.
+	 * Safe because perf_callchain_user enforces USER_DS.
+	 */
 	if (!access_ok(VERIFY_READ, tail, sizeof(buftail)))
 		return NULL;
 
@@ -81,7 +83,9 @@ compat_user_backtrace(struct compat_frame_tail __user *tail,
 	struct compat_frame_tail buftail;
 	unsigned long err;
 
-	/* Also check accessibility of one struct frame_tail beyond */
+	/* Also check accessibility of one struct frame_tail beyond.
+	 * Safe because perf_callchain_user enforces USER_DS.
+	 */
 	if (!access_ok(VERIFY_READ, tail, sizeof(buftail)))
 		return NULL;
 
@@ -109,6 +113,7 @@ compat_user_backtrace(struct compat_frame_tail __user *tail,
 void perf_callchain_user(struct perf_callchain_entry *entry,
 			 struct pt_regs *regs)
 {
+	mm_segment_t oldfs = get_fs();
 	if (perf_guest_cbs && perf_guest_cbs->is_in_guest()) {
 		/* We don't support guest os callchain now */
 		return;
@@ -116,6 +121,7 @@ void perf_callchain_user(struct perf_callchain_entry *entry,
 
 	perf_callchain_store(entry, regs->pc);
 
+	set_fs(USER_DS);
 	if (!compat_user_mode(regs)) {
 		/* AARCH64 mode */
 		struct frame_tail __user *tail;
@@ -137,6 +143,7 @@ void perf_callchain_user(struct perf_callchain_entry *entry,
 			tail = compat_user_backtrace(tail, entry);
 #endif
 	}
+	set_fs(oldfs);
 }
 
 /*
diff --git a/arch/x86/events/core.c b/arch/x86/events/core.c
index 041e442..e2fcbbf 100644
--- a/arch/x86/events/core.c
+++ b/arch/x86/events/core.c
@@ -2282,7 +2282,7 @@ perf_callchain_user32(struct pt_regs *regs, struct perf_callchain_entry *entry)
 		frame.next_frame     = 0;
 		frame.return_address = 0;
 
-		if (!access_ok(VERIFY_READ, fp, 8))
+		if (!valid_user_frame(fp, sizeof(frame)))
 			break;
 
 		bytes = __copy_from_user_nmi(&frame.next_frame, fp, 4);
@@ -2292,9 +2292,6 @@ perf_callchain_user32(struct pt_regs *regs, struct perf_callchain_entry *entry)
 		if (bytes != 0)
 			break;
 
-		if (!valid_user_frame(fp, sizeof(frame)))
-			break;
-
 		perf_callchain_store(entry, cs_base + frame.return_address);
 		fp = compat_ptr(ss_base + frame.next_frame);
 	}
@@ -2342,7 +2339,7 @@ perf_callchain_user(struct perf_callchain_entry *entry, struct pt_regs *regs)
 		frame.next_frame	     = NULL;
 		frame.return_address = 0;
 
-		if (!access_ok(VERIFY_READ, fp, 16))
+		if (!valid_user_frame(fp, sizeof(frame)))
 			break;
 
 		bytes = __copy_from_user_nmi(&frame.next_frame, fp, 8);
@@ -2352,9 +2349,6 @@ perf_callchain_user(struct perf_callchain_entry *entry, struct pt_regs *regs)
 		if (bytes != 0)
 			break;
 
-		if (!valid_user_frame(fp, sizeof(frame)))
-			break;
-
 		perf_callchain_store(entry, frame.return_address);
 		fp = (void __user *)frame.next_frame;
 	}
-- 
2.8.0.rc3.226.g39d4020

